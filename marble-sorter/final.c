#pragma config(Sensor, in1,    lightSensor,    sensorReflection)
#pragma config(Sensor, dgtl1,  marbleDistance, sensorSONAR_mm)
#pragma config(Motor,  port2,           marblePusher,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           sorterMotor,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           flash,         tmotorVexFlashlight, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define MARBLE_COUNT 4
#define WOOD_REFLECT 165
#define PLASTIC_REFLECT 136
#define METAL_REFLECT 150
#define GLASS_REFLECT 170

#define WOOD 1
#define PLASTIC 2
#define METAL 3
#define GLASS 4
#define RELOAD_WAIT 4

int detectBall();
void pushBall();

task main() {
	motor[flash] = 127;
	wait(1.5);
	while (true) {
		pushBall();
		wait(2);
		for (int i = 0; i < MARBLE_COUNT; i++) {
			//detect ball
			int ballType = detectBall();
			//int ballType = GLASS;
			wait(1.5);
			switch (ballType) {
			case WOOD:
				wait(RELOAD_WAIT);
				pushBall();
				break;

			case PLASTIC:
				motor[sorterMotor] = 25;
				wait(0.75);
				stopMotor(sorterMotor);
				pushBall();
				wait(RELOAD_WAIT);
				motor[sorterMotor] = -25;
				wait(0.9);
				break;

			case METAL:
				motor[sorterMotor] = 40;
				wait(0.75);
				stopMotor(sorterMotor);
				pushBall();
				wait(RELOAD_WAIT);
				motor[sorterMotor] = -40;
				wait(0.9);
				stopMotor(sorterMotor);
				break;

			case GLASS:
				startMotor(sorterMotor, 50);
				wait(0.95);
				stopMotor(sorterMotor);
				pushBall();
				wait(RELOAD_WAIT);
				startMotor(sorterMotor, -50);
				wait(1.15);
				stopMotor(sorterMotor);
				break;

			default:
				break;
			}
			pushBall();
		}
		break;
	}

}

int detectBall() {
	int marbleReflectValue = SensorValue(lightSensor);
	//default
	int ballType = GLASS;

	if (marbleReflectValue >= WOOD_REFLECT - 5 && marbleReflectValue <= WOOD_REFLECT + 5) {
		ballType = WOOD;
	}
	else if (marbleReflectValue >= PLASTIC_REFLECT - 5 && marbleReflectValue <= PLASTIC_REFLECT + 5) {
		ballType = PLASTIC;
	}
	else if (marbleReflectValue >= METAL_REFLECT - 5 && marbleReflectValue <= METAL_REFLECT + 5) {
		ballType = METAL;
	}
	else if (marbleReflectValue >= GLASS_REFLECT - 5 && marbleReflectValue <= GLASS_REFLECT + 5) {
		ballType = GLASS;
	}
	return ballType;
}

void pushBall() {
	if (SensorValue(marbleDistance) <= 50) {
		motor[marblePusher] = 23;
		wait(0.3);
		motor[marblePusher] = 0;
	}
	else {
		motor[marblePusher] = 23;
		waitUntil(SensorValue(marbleDistance) <= 50);
		motor[marblePusher] = 0;
	}
}
